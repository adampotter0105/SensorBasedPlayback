#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    goalpot,        sensorPotentiometer)
#pragma config(Sensor, in2,    conepot,        sensorPotentiometer)
#pragma config(Sensor, in3,    intakepot,      sensorPotentiometer)
#pragma config(Sensor, in4,    yaw,            sensorGyro)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           BL,            tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           FL,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           barL,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           goalL,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           intake,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           intake2,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           goalR,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           barR,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           FR,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          BR,            tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/
// Two Controller: ex. "vexRt[Btn5DXmtr2]"
// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

///Include Arrays///
#include "94(comp).h"

// SENSOR DEFINITIONS
#define GOALMIN 800  // mobile goal 4-bar
#define GOALMAX 2550

#define INTAKEOPEN 1400 //max open
#define INTAKETHRESH1 2300 //between closed and holding cone

//BAR Sections   [target, low, high]
#define BARMIN 1330 // physical limits
#define BARMAX 3800
int barLOW[3] = {1000, 1000, 1450};
int barMID[3] = {2150, 1450, 2200};
int barHI[3] = {3200, 2200, 4001};

//DRIVE PID VARIABLES//
const float kL = 0.06; //Kp value for usercontrol integrated PID
const float kR = 0.06;
const float kG = 0.07;
#define MAXL 0.93 //max fraction of full power output while recording (so in auton it can compensate)
#define MAXR 0.93
float maxL; //fraction of max power allowed
float maxR;

//////////////////////
// GLOBAL VARIABLES///
//////////////////////

int PIDon = 0; // 0:driveL 1:drive 2:turn 3:mobilegoal 4:cone-bar 5:lift
float target = 0;
int motorMin = 20;  //defining dead space for motors
const float kP = 0.1;
const float kI = 0;
const float kD = 0;

int dT = 100;  // ms delay
int dTplayback = 100; //max motor output

int intakeon = 0;

float motorOut = 0;

//Record/Playback
int TError = 1.0; //0%
int turnError=0;

int posL = 0; //position in array
int posR = 0;
int posT = 0;
int posB = 0;
int posI = 0;
//encoder: 392 for turbo, 627.2 for torque


///////////
// TASKS///
///////////


task PID()
{ int sensor=0;
	int totalError = 0;
	float lastError = 0;
	float dError = 0;
	float error = 0;
	while(true)
	{ //Sensors
		if(PIDon){sensor=SensorValue(conepot);}
		//P
		error=target-sensor;
		//I
		totalError+=error;
		//D
		dError=lastError-error;
		//Motor Output
		motorOut=kP*error+kI*totalError+kD*dError;
		if(fabs(motorOut)>100)  {motorOut=sgn(motorOut)*100;}//round down to 100
		if(PIDon&&fabs(motorOut)>motorMin){motor[barL]=motor[barR]=motorOut;}  //Cone Bar
		else if(PIDon) {motor[barL]=motor[barR]=0;}
		//Last Error
		lastError=error;
		delay(dT);
	}//end of infinite loop
}//end of PID task




////INTAKE TOGGLE////
task intaketoggle()
{
	while(true){
		if(vexRT[Btn7D]==1 || vexRT[Btn7DXmtr2]==1){ //if button pressed

			if(intakeon) {intakeon=0; //closing
				motor[intake]=motor[intake2]=-120; delay(400);
				if(SensorValue(intakepot)>INTAKETHRESH1)
				{motor[intake]=motor[intake2]=-30; delay(250); motor[intake]=motor[intake2]=0;} //closes on nothing
				else {motor[intake]=motor[intake2]=-30;} //closes on cone

			}

			else {intakeon=1;
				motor[intake]=motor[intake2]=120; delay(350);//opening
				motor[intake]=motor[intake2]=30; delay(200);
				motor[intake]=motor[intake2]=0;}
		}
		delay(50);
	}//end of infinite loop
}//end of task




///RECORD///

task record()
{  while(true){
		//Outside record
		maxL=maxR=1;


		/////////////////
		//OUTPUT ARRAYS//
		/////////////////

		//Left Drive
		if(vexRT[Btn7LXmtr2]==1){string foo;
			clearDebugStream();
			writeDebugStreamLine("int L[600]={");
			for(int i=0;i<600;i++){foo=L[i]; if(i%15==0){writeDebugStreamLine(foo);}else{writeDebugStream(foo);} writeDebugStream(", ");}
			writeDebugStreamLine("};");
		}//end of array value out

		//Right Drive
		if(vexRT[Btn7RXmtr2]==1){string foo;
			clearDebugStream();
			writeDebugStreamLine("int R[600]={");
			for(int i=0;i<600;i++){foo=R[i]; if(i%15==0){writeDebugStreamLine(foo);}else{writeDebugStream(foo);} writeDebugStream(", ");}
			writeDebugStreamLine("};");
		}//end of array value out

		//gyro
		if(vexRT[Btn8LXmtr2]==1){string foo;
			clearDebugStream();
			writeDebugStreamLine("int G[600]={");
			for(int i=0;i<600;i++){foo=G[i]; if(i%15==0){writeDebugStreamLine(foo);}else{writeDebugStream(foo);} writeDebugStream(", ");}
			writeDebugStreamLine("};");
		}//end of array value out

		if(vexRT[Btn8RXmtr2]==1){string foo;
			clearDebugStream();
			//T
			writeDebugStreamLine("int T[250]={");
			for(int i=0;i<250;i++){foo=T[i]; if(i%15==0){writeDebugStreamLine(foo);}else{writeDebugStream(foo);} writeDebugStream(", ");}
			writeDebugStreamLine("};");
			//B
			writeDebugStreamLine("int B[250]={");
			for(int i=0;i<250;i++){foo=B[i]; if(i%15==0){writeDebugStreamLine(foo);}else{writeDebugStream(foo);} writeDebugStream(", ");}
			writeDebugStreamLine("};");
			//I
			writeDebugStreamLine("int In[150]={");
			for(int i=0;i<150;i++){foo=In[i]; if(i%15==0){writeDebugStreamLine(foo);}else{writeDebugStream(foo);} writeDebugStream(", ");}
			writeDebugStreamLine("};");

		}//end of array value conditional

		//Record
		if(vexRT[Btn7U]==1||vexRT[Btn7UXmtr2]==1){ // if buttons pressed

			posL=0; posR=0; posT=0; posB=0; posI=0; //reset positions
			maxL=MAXL; maxR=MAXR;


			for(int j=0;j<600;j++){L[j]=0;}    //Clear arrays
			for(int j=0;j<600;j++){R[j]=0;}
			for(int j=0;j<600;j++){G[j]=0;}
			for(int j=0;j<250;j++){T[j]=0;}
			for(int j=0;j<250;j++){B[j]=0;}
			for(int j=0;j<150;j++){In[j]=0;}

			resetMotorEncoder(BL);//clear encoders
			resetMotorEncoder(BR);


			T[0]=2850; T[1]=0;
			int t=0;

			while(true) {//Loop



				//Drive
				L[t/dTplayback]= getMotorEncoder(BL) + ((1/kL)*motor[BL]); //Left, stores target every time
				R[t/dTplayback]= -getMotorEncoder(BR) + ((1/kR)*motor[BR]); //Right
				//Gyro
				G[t/dTplayback]= SensorValue(yaw);

				//Necessary to Keep Loop Working
				t+=dTplayback; delay(dTplayback);
				//Break
				if(vexRT[Btn8U]==1||vexRT[Btn8UXmtr2]==1||t>59940){break;}

				//Bottom Bar
				if(motor[goalL]!=B[posB]){B[posB+2]=motor[goalL]; B[posB+3]=t; posB+=2;}//if big change if power, take pwr and timestamp
				//forward two, evens pwr, odds time

				//Intake
				if(motor[intake]!=In[posI]){In[posI+2]=motor[intake]; In[posI+3]=t; posI+=2;}//if change in power, take sample

				//Top Bar
				if(PIDon) { //saving values for bar if PIDon
					if(target!=T[posT])    {T[posT+2]=target; T[posT+3]=t; posT+=2;}    }//if pid is on
				else {    if(motor[barL]!=T[posT])    {T[posT+2]=motor[barL]; T[posT+3]=t; posT+=2;}    }//if pid is off


			} //end of 2nd infinite loop
		}//end of if

	}//end of 1st infinite loop
}//end of task



/////////////
//PRE-AUTON//
/////////////
void pre_auton(){
	//PASTE ARRAYS//

}




/////////////
///PLAYBACK//
/////////////


task autonomous()
{ stopTask(intaketoggle);

	posL=posR=posT=posB=posL=posI=0;//reset position
	startTask(PID);
	PIDon=0;//turning off pid

	///Main//
	//PLAYBACK
	int t=0; //time marker
	//Starting sequence
	resetMotorEncoder(BL);//clear encoders
	resetMotorEncoder(BR);


	//Actual Playback
	while(true)
	{
		//Drive
		turnError=kG*(G[t/dTplayback]-SensorValue(yaw));


		motor[BL]=motor[FL]=(int)(kL*TError*(L[t/dTplayback]-getMotorEncoder(BL))+turnError);//L   using proportional and same targets as drive

		motor[BR]=motor[FR]=(int)(kR*TError*(R[t/dTplayback]+getMotorEncoder(BR))-turnError);

		//Bars and Intake
		if(B[posB+1]==t){motor[goalL]=motor[goalR]=B[posB]; posB+=2;}//playing back arrays
		if(In[posI+1]==t){motor[intake]=motor[intake2]=In[posI]; posI+=2;}

		//Top Bar
		if(T[posT+1]==t){//if time is right
			if(abs(T[posT])==127) {PIDon=0; motor[barL]=motor[barR]=T[posT]; posT+=2;}//if power is 127/-127
			else{PIDon=1; target=T[posT]; posT+=2;}  }

		//Necessary to Loop
		t+=dTplayback;
		delay(dTplayback);
		if(t>59900){break;}

		//End of additions
	} //end of for

	//End with all motors zero
	motor[FL]=motor[FR]=motor[BL]=motor[BR]=0;
	motor[intake]=motor[intake2]=motor[barL]=motor[barR]=0;
	motor[goalL]=motor[goalR]=0;
	//End
}





///////////////////
////USER CONTROL///
///////////////////

task usercontrol()
{ //Tasks
	startTask(PID);
	startTask(record);

	//Starting sequence
	startTask(intaketoggle);

	//LOOP
	while (true)
	{   //DELAY
		delay(50);

		//Drive
		motor[BL]=motor[FL]=vexRT[Ch3]*maxL;
		motor[BR]=motor[FR]=vexRT[Ch2]*maxR;

		//Mobile Goal
		if(SensorValue(goalpot)>GOALMIN&&(vexRT[Btn6U]||vexRT[Btn6UXmtr2])) { motor[goalL]=motor[goalR]=127;}  //unaffected by stack
		else if(SensorValue(goalpot)<GOALMAX&&(vexRT[Btn6D]||vexRT[Btn6DXmtr2])) { motor[goalL]=motor[goalR]=-127;}
		else  {if(SensorValue(goalpot)>GOALMAX-250){motor[goalL]=motor[goalR]=-30;}//pulls down bar if close to bottom
			else{motor[goalL]=motor[goalR]=0;}}

		//Manual ConeBar
		if(SensorValue(conepot)>BARMIN&&(vexRT[Btn5DXmtr2]||vexRT[Btn5D])) {PIDon=0; motor[barL]=motor[barR]=-127;}  //button press
		else if(SensorValue(conepot)<BARMAX-500&&(vexRT[Btn5UXmtr2]||vexRT[Btn5U])) {PIDon=0; motor[barL]=motor[barR]=127;}
		else if(PIDon==0){motor[barL]=motor[barR]=0; PIDon=1;
			if(SensorValue(conepot)>barLOW[1]&&SensorValue(conepot)<barLOW[2])    {target=barLOW[0];}//interval 1
			if(SensorValue(conepot)>barMID[1]&&SensorValue(conepot)<barMID[2])    {target=barMID[0];}//interval 2
			if(SensorValue(conepot)>barHI[1]&&SensorValue(conepot)<barHI[2])    {target=barHI[0];}//interval 3
		}


	}//end of infinite loop
}//end of
